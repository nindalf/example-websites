<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width" /><meta charSet="utf-8" /><link rel="icon" href="/favicon.ico" /><title>How Goroutines Work</title><meta name="charset" content="utf-8" /><meta name="author" content="Krishna Sundarram" /><meta name="description" content="Krishna&#x27;s personal blog" /><link href="https://blog.nindalf.com/index.xml" rel="alternate" type="application/rss+xml" title="Krishna&#x27;s personal blog" /><meta name="next-head-count" content="8" /><link rel="preload" href="/_next/static/css/37c6e985df8853b529b3.css" as="style" /><link rel="stylesheet" href="/_next/static/css/37c6e985df8853b529b3.css" data-n-g="" /><link rel="preload" href="/_next/static/css/740b20632ac80250c7f0.css" as="style" /><link rel="stylesheet" href="/_next/static/css/740b20632ac80250c7f0.css" data-n-p="" /><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-18c200bfa4628d9da94c.js" as="script" /><link rel="preload" href="/_next/static/chunks/framework-5e33f488d9410ce9ba9d.js" as="script" /><link rel="preload" href="/_next/static/chunks/597-e9cbf8ad4e8557f256b3.js" as="script" /><link rel="preload" href="/_next/static/chunks/778-c9e86f308cd9cb372f22.js" as="script" /><link rel="preload" href="/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" as="script" /><link rel="preload" href="/_next/static/chunks/pages/_app-33eebf5131cfd5d17810.js" as="script" /><link rel="preload" href="/_next/static/chunks/941-89b1c2f25315e4a44edb.js" as="script" /><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-4aeed08a217f27d1079a.js" as="script" /></head><body><div id="__next"><div><header class="utils_header__1rqd-"><ul class="utils_headingLg__de7p0"><li class="utils_headingLg__de7p0"><a href="/about/">About</a></li><li class="utils_headingLg__de7p0"><a href="/">Home</a></li></ul></header><main><article><h1>How Goroutines Work</h1><div class="utils_lightText__12Ckm"><time dateTime="2014-02-23">February 23, 2014</time> <div>6<!-- --> min read</div></div><div><h3>Introduction to Go</h3>
<p>If you are new to the Go programming language, or if the sentence "Concurrency is not parallelism" means nothing to you, then check out Rob Pike's <a href="https://www.youtube.com/watch?v=cN_DpYBzKso">excellent talk on the subject</a>. Its 30 minutes long, and I guarantee that watching it is 30 minutes well spent.</p>
<p>To summarize the difference - "when people hear the word concurrency they often think of parallelism, a related but quite distinct concept. In programming, concurrency is the composition of independently executing processes, while parallelism is the simultaneous execution of (possibly related) computations. Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once." <sup>[1]</sup></p>
<p>Go allows us to write concurrent programs. It provides goroutines and importantly, the ability to communicate between them. I will focus on the former.</p>
<h3>Goroutines and Threads - the differences</h3>
<p>Go uses goroutines while a language like Java uses threads. What are the differences between the two? We need to look at 3 factors - memory consumption, setup and teardown and switching time.</p>
<h4>Memory consumption</h4>
<p>The creation of a goroutine does not require much memory - only 2kB of stack space. They grow by allocating and freeing heap storage as required.<sup>[2][3]</sup> Threads on the other hand start out at 1Mb (500 times more), along with a region of memory called a guard page that acts as a guard between one thread's memory and another.<sup>[7]</sup></p>
<p>A server handling incoming requests can therefore create one goroutine per request without a problem, but one thread per request will eventually lead to the dreaded OutOfMemoryError. This isn't limited to Java - any language that uses OS threads as the primary means of concurrency will face this issue.</p>
<h4>Setup and teardown costs</h4>
<p>Threads have significant setup and teardown costs because it has to request resources from the OS and return it once its done. The workaround to this problem is to maintain a pool of threads. In contrast, goroutines are created and destroyed by the runtime and those operations are pretty cheap. The language doesn't support manual management of goroutines.</p>
<h4>Switching costs</h4>
<p>When a thread blocks, another has to be scheduled in its place. Threads are scheduled preemptively, and during a thread switch, the scheduler needs to save/restore ALL registers, that is, 16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc. This is quite significant when there is rapid switching between threads.</p>
<p>Goroutines are scheduled cooperatively and when a switch occurs, only 3 registers need to be saved/restored - Program Counter, Stack Pointer and DX. The cost is much lower.</p>
<p>As discussed earlier, the number of goroutines is generally much higher, but that doesn't make a difference to switching time for two reasons. Only runnable goroutines are considered, blocked ones aren't. Also, modern schedulers are O(1) complexity, meaning switching time is not affected by the number of choices (threads or goroutines).<sup>[5]</sup></p>
<h3>How goroutines are executed</h3>
<p>As mentioned earlier, the runtime manages the goroutines throughout from creation to scheduling to teardown. The runtime is allocated a few threads on which all the goroutines are multiplexed. At any point of time, each thread will be executing one goroutine. If that goroutine is blocked, then it will be swapped out for another goroutine that will execute on that thread instead.<sup>[6]</sup></p>
<p>As the goroutines are scheduled cooperatively, a goroutine that loops continuously can starve other goroutines on the same thread. In Go 1.2, this problem is somewhat alleviated by occasionally invoking the Go scheduler when entering a function, so a loop that includes a non-inlined function call can be prempted.</p>
<h3>Goroutines blocking</h3>
<p>Goroutines are cheap and do not cause the thread on which they are multiplexed to block if they are blocked on</p>
<ul>
<li>network input</li>
<li>sleeping</li>
<li>channel operations or</li>
<li>blocking on primitives in the sync package.</li>
</ul>
<p>Even if tens of thousands of goroutines have been spawned, it's not a waste of system resources if most of them are blocked on one of these since the runtime schedules another goroutine instead.</p>
<p>In simple terms, goroutines are a lightweight abstraction over threads. A Go programmer does not deal with threads, and similarly the OS is not aware of the existence of goroutines. From the OS's perspective, a Go program will behave like an event-driven C program. <sup>[5]</sup></p>
<h3>Threads and processors</h3>
<p>Although you cannot directly control the number of threads that the runtime will create, it is possible to set the number of processor cores used by the program. This is done by setting the variable <code>GOMAXPROCS</code> with a call to <code>runtime.GOMAXPROCS(n)</code>. Increasing the number of cores may not necessarily improve the performance of your program, depending on its design. The profiling tools can be used to find the ideal number of cores for your program.</p>
<h3>Closing thoughts</h3>
<p>As with other languages, it is important to prevent simultaneous access of shared resources by more than one goroutine. It is best to transfer data between goroutines using channels, ie, <a href="https://blog.golang.org/share-memory-by-communicating">do not communicate by sharing memory; instead, share memory by communicating</a>.</p>
<p>Lastly, I'd strongly recommend you check out <a href="https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf">Communicating Sequential Processes</a> by C. A. R. Hoare. This man was truly a genius. In this paper (published 1978) he predicted how the single core performance of processors would eventually plateau and chip-makers would instead increase the number of cores. His proposal to exploit this had a deep influence on the design of Go.</p>
<h3>Footnotes</h3>
<ul>
<li>
<p><a href="https://blog.golang.org/concurrency-is-not-parallelism">1</a> - Concurrency is not parallelism by Rob Pike</p>
</li>
<li>
<p><a href="https://golang.org/doc/effective_go.html#goroutines">2</a> - Effective Go: Goroutines</p>
</li>
<li>
<p><a href="https://golang.org/doc/go1.4#runtime">3</a> - Goroutine stack size was decreased from 8kB to 2kB in Go 1.4.</p>
</li>
<li>
<p><a href="http://agis.io/2014/03/25/contiguous-stacks-in-go.html">4</a> - Goroutine stacks became contiguous in Go 1.3.</p>
</li>
<li>
<p><a href="https://groups.google.com/forum/#!topic/golang-nuts/j51G7ieoKh4">5</a> - Dmitry Vyukov explains scheduling of goroutines on golang-nuts</p>
</li>
<li>
<p><a href="http://www1.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf">6</a> - Analysis of the Go runtime scheduler by Deshpande et al.</p>
</li>
<li>
<p><a href="http://dave.cheney.net/2014/06/07/five-things-that-make-go-fast">7</a> - 5 things that make Go fast by Dave Cheney</p>
</li>
</ul>
<h3>Further Reading</h3>
<p>If you're interested in learning more about Go, there are a couple great talks about the language here</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=f6kdp27TYZs%E2%80%8E">Go Concurrency Patterns</a> by Rob Pike</li>
<li><a href="https://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a> by Sameer Ajmani.</li>
</ul>
</div></article></main><div class="utils_backToHome__2ednK"><a href="/">‚Üê Home</a></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"how-goroutines-work","wordCount":1009,"timeToRead":6,"contentHtml":"\u003ch3\u003eIntroduction to Go\u003c/h3\u003e\n\u003cp\u003eIf you are new to the Go programming language, or if the sentence \"Concurrency is not parallelism\" means nothing to you, then check out Rob Pike's \u003ca href=\"http://www.youtube.com/watch?v=cN_DpYBzKso\"\u003eexcellent talk on the subject\u003c/a\u003e. Its 30 minutes long, and I guarantee that watching it is 30 minutes well spent.\u003c/p\u003e\n\u003cp\u003eTo summarize the difference - \"when people hear the word concurrency they often think of parallelism, a related but quite distinct concept. In programming, concurrency is the composition of independently executing processes, while parallelism is the simultaneous execution of (possibly related) computations. Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.\" \u003csup\u003e[1]\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003eGo allows us to write concurrent programs. It provides goroutines and importantly, the ability to communicate between them. I will focus on the former.\u003c/p\u003e\n\u003ch3\u003eGoroutines and Threads - the differences\u003c/h3\u003e\n\u003cp\u003eGo uses goroutines while a language like Java uses threads. What are the differences between the two? We need to look at 3 factors - memory consumption, setup and teardown and switching time.\u003c/p\u003e\n\u003ch4\u003eMemory consumption\u003c/h4\u003e\n\u003cp\u003eThe creation of a goroutine does not require much memory - only 2kB of stack space. They grow by allocating and freeing heap storage as required.\u003csup\u003e[2][3]\u003c/sup\u003e Threads on the other hand start out at 1Mb (500 times more), along with a region of memory called a guard page that acts as a guard between one thread's memory and another.\u003csup\u003e[7]\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003eA server handling incoming requests can therefore create one goroutine per request without a problem, but one thread per request will eventually lead to the dreaded OutOfMemoryError. This isn't limited to Java - any language that uses OS threads as the primary means of concurrency will face this issue.\u003c/p\u003e\n\u003ch4\u003eSetup and teardown costs\u003c/h4\u003e\n\u003cp\u003eThreads have significant setup and teardown costs because it has to request resources from the OS and return it once its done. The workaround to this problem is to maintain a pool of threads. In contrast, goroutines are created and destroyed by the runtime and those operations are pretty cheap. The language doesn't support manual management of goroutines.\u003c/p\u003e\n\u003ch4\u003eSwitching costs\u003c/h4\u003e\n\u003cp\u003eWhen a thread blocks, another has to be scheduled in its place. Threads are scheduled preemptively, and during a thread switch, the scheduler needs to save/restore ALL registers, that is, 16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc. This is quite significant when there is rapid switching between threads.\u003c/p\u003e\n\u003cp\u003eGoroutines are scheduled cooperatively and when a switch occurs, only 3 registers need to be saved/restored - Program Counter, Stack Pointer and DX. The cost is much lower.\u003c/p\u003e\n\u003cp\u003eAs discussed earlier, the number of goroutines is generally much higher, but that doesn't make a difference to switching time for two reasons. Only runnable goroutines are considered, blocked ones aren't. Also, modern schedulers are O(1) complexity, meaning switching time is not affected by the number of choices (threads or goroutines).\u003csup\u003e[5]\u003c/sup\u003e\u003c/p\u003e\n\u003ch3\u003eHow goroutines are executed\u003c/h3\u003e\n\u003cp\u003eAs mentioned earlier, the runtime manages the goroutines throughout from creation to scheduling to teardown. The runtime is allocated a few threads on which all the goroutines are multiplexed. At any point of time, each thread will be executing one goroutine. If that goroutine is blocked, then it will be swapped out for another goroutine that will execute on that thread instead.\u003csup\u003e[6]\u003c/sup\u003e\u003c/p\u003e\n\u003cp\u003eAs the goroutines are scheduled cooperatively, a goroutine that loops continuously can starve other goroutines on the same thread. In Go 1.2, this problem is somewhat alleviated by occasionally invoking the Go scheduler when entering a function, so a loop that includes a non-inlined function call can be prempted.\u003c/p\u003e\n\u003ch3\u003eGoroutines blocking\u003c/h3\u003e\n\u003cp\u003eGoroutines are cheap and do not cause the thread on which they are multiplexed to block if they are blocked on\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003enetwork input\u003c/li\u003e\n\u003cli\u003esleeping\u003c/li\u003e\n\u003cli\u003echannel operations or\u003c/li\u003e\n\u003cli\u003eblocking on primitives in the sync package.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEven if tens of thousands of goroutines have been spawned, it's not a waste of system resources if most of them are blocked on one of these since the runtime schedules another goroutine instead.\u003c/p\u003e\n\u003cp\u003eIn simple terms, goroutines are a lightweight abstraction over threads. A Go programmer does not deal with threads, and similarly the OS is not aware of the existence of goroutines. From the OS's perspective, a Go program will behave like an event-driven C program. \u003csup\u003e[5]\u003c/sup\u003e\u003c/p\u003e\n\u003ch3\u003eThreads and processors\u003c/h3\u003e\n\u003cp\u003eAlthough you cannot directly control the number of threads that the runtime will create, it is possible to set the number of processor cores used by the program. This is done by setting the variable \u003ccode\u003eGOMAXPROCS\u003c/code\u003e with a call to \u003ccode\u003eruntime.GOMAXPROCS(n)\u003c/code\u003e. Increasing the number of cores may not necessarily improve the performance of your program, depending on its design. The profiling tools can be used to find the ideal number of cores for your program.\u003c/p\u003e\n\u003ch3\u003eClosing thoughts\u003c/h3\u003e\n\u003cp\u003eAs with other languages, it is important to prevent simultaneous access of shared resources by more than one goroutine. It is best to transfer data between goroutines using channels, ie, \u003ca href=\"https://blog.golang.org/share-memory-by-communicating\"\u003edo not communicate by sharing memory; instead, share memory by communicating\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eLastly, I'd strongly recommend you check out \u003ca href=\"http://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf\"\u003eCommunicating Sequential Processes\u003c/a\u003e by C. A. R. Hoare. This man was truly a genius. In this paper (published 1978) he predicted how the single core performance of processors would eventually plateau and chip-makers would instead increase the number of cores. His proposal to exploit this had a deep influence on the design of Go.\u003c/p\u003e\n\u003ch3\u003eFootnotes\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"http://blog.golang.org/concurrency-is-not-parallelism\"\u003e1\u003c/a\u003e - Concurrency is not parallelism by Rob Pike\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"http://golang.org/doc/effective_go.html#goroutines\"\u003e2\u003c/a\u003e - Effective Go: Goroutines\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"http://golang.org/doc/go1.4#runtime\"\u003e3\u003c/a\u003e - Goroutine stack size was decreased from 8kB to 2kB in Go 1.4.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"http://agis.io/2014/03/25/contiguous-stacks-in-go.html\"\u003e4\u003c/a\u003e - Goroutine stacks became contiguous in Go 1.3.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://groups.google.com/forum/#!topic/golang-nuts/j51G7ieoKh4\"\u003e5\u003c/a\u003e - Dmitry Vyukov explains scheduling of goroutines on golang-nuts\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"http://www1.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf\"\u003e6\u003c/a\u003e - Analysis of the Go runtime scheduler by Deshpande et al.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"http://dave.cheney.net/2014/06/07/five-things-that-make-go-fast\"\u003e7\u003c/a\u003e - 5 things that make Go fast by Dave Cheney\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eFurther Reading\u003c/h3\u003e\n\u003cp\u003eIf you're interested in learning more about Go, there are a couple great talks about the language here\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://www.youtube.com/watch?v=f6kdp27TYZs%E2%80%8E\"\u003eGo Concurrency Patterns\u003c/a\u003e by Rob Pike\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.youtube.com/watch?v=QDDwwePbDtw\"\u003eAdvanced Go Concurrency Patterns\u003c/a\u003e by Sameer Ajmani.\u003c/li\u003e\n\u003c/ul\u003e\n","preview":"Introduction to Go","title":"How Goroutines Work","date":"2014-02-23","aliases":["how-goroutines-work"],"tags":["tech"]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"how-goroutines-work"},"buildId":"Jf-wop3a-jR8I9PxYMsgo","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-8683bd742a84c1edd48c.js"></script><script src="/_next/static/chunks/webpack-18c200bfa4628d9da94c.js" async=""></script><script src="/_next/static/chunks/framework-5e33f488d9410ce9ba9d.js" async=""></script><script src="/_next/static/chunks/597-e9cbf8ad4e8557f256b3.js" async=""></script><script src="/_next/static/chunks/778-c9e86f308cd9cb372f22.js" async=""></script><script src="/_next/static/chunks/main-9ca82ec4d4aca520c43d.js" async=""></script><script src="/_next/static/chunks/pages/_app-33eebf5131cfd5d17810.js" async=""></script><script src="/_next/static/chunks/941-89b1c2f25315e4a44edb.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4aeed08a217f27d1079a.js" async=""></script><script src="/_next/static/Jf-wop3a-jR8I9PxYMsgo/_buildManifest.js" async=""></script><script src="/_next/static/Jf-wop3a-jR8I9PxYMsgo/_ssgManifest.js" async=""></script><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "e957a0fd477941f5a9aa5fc4be0670df"}'></script></body></html>